structure RegAlloc : REG_ALLOC =
struct
  structure Frame = MipsFrame
  type allocation = Frame.register Temp.Map.map

  fun rewrite (instrs, frame, spilledNodes) =
    let fun rewrite1 (instrs, t) =
          let val ae = Frame.exp (Frame.allocLocal(frame) true) (Tree.TEMP Frame.FP)
              fun genInstrs (is_def, t) =
                if is_def then MipsGen.codegen(frame) (Tree.MOVE(ae, Tree.TEMP t)) else MipsGen.codegen(frame) (Tree.MOVE(Tree.TEMP t, ae))

              fun allocDu (is_def, dus, t) =
                if List.exists (fn x => x = t) dus then (gen_instrs(is_def, Temp.newtemp()); map (fn x => if x = t then Temp.newtemp() else x) dus)
                else ([], dus)

              fun transInstr instr = 
                case instr of
 
  fun alloc (instrs, iGraph, frame)  =
    let fun tempname (alloc, temp) =
          case Temp.Table.look(alloc, temp) of
            SOME(r) => r
	   | NONE => Frame.lookreg temp        
         val (colored, spilledNodes) = Color.color{interference = iGraph, initialAlloc = Frame.tempMap, registers = Frame.registers}
     in
        if spilledNodes = [] then (instrs, colored)
        else alloc(rewrite(instrs, frame, spilledNodes), frame)
     end
end
